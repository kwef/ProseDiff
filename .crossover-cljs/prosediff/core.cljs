; DO NOT EDIT THIS FILE! IT WAS AUTOMATICALLY GENERATED BY
; lein-cljsbuild FROM THE FOLLOWING SOURCE FILE:
; file:/Users/kennethfoner/Dropbox/Programming/ProseDiff/Clojure%20attempt/ProseDiff/src-clj/prosediff/core.clj

(ns prosediff.core
    (:gen-class)
    (:require [clojure.set]))

;; Gets a list of a range of characters from c1 to c2, in ASCII order.
(defn char-range [c1 c2]
    (map char (range (int c1) (+ 1 (int c2)))))

;; The list of characters considered to be part of a word.
(def word-chars (set (concat (char-range \A \Z)
                             (char-range \a \z)
                             (char-range \0 \9)
                             (list \' \-))))

;; Strip spaces from words as they are split. Current algorithm will re-insert them after matching is complete. For certain variants of matching, it may be necessary to keep spaces in the words list.
(def strip-spaces-in-split true)

;; Splits a string to component words, preserving non-word characters as their own words. Spaces are removed; they can be reinserted later using Algorithms.
(defn split-to-words [string]
    (reverse
        (map #(apply str (reverse %))
            (loop [s string
                   word ""
                   words nil]
                (if (empty? s)
                    (if (empty? word)
                        words
                        (cons word words))
                    (if (contains? word-chars (first s))
                        (recur (rest s)
                               (cons (first s) word)
                               words)
                        (recur (rest s)
                               nil
                               (if (and strip-spaces-in-split
                                        (= \space (first s)))
                                   (if (empty? word)
                                       words
                                       (cons word words))
                                   (cons (list (first s))
                                         (if (empty? word)
                                             words
                                             (cons word words)))))))))))

;; Makes a list of vectors [index word] from a list of words
(defn indexed-word-list [word-list]
    (map vector (iterate inc 0) word-list))

;; Takes a list of objects and an unary function, and generates a hash-table where the keys are the result of the application of that function to each object, and the values are vectors containing the val-func of every object which was mapped to that key.
(defn pigeonhole [L key-func val-func]
  (apply merge-with
         (comp vec flatten vector)
         (map (partial apply hash-map)
              (map #(vector (key-func %) (vector (val-func %)))
                   L))))

;; Maps a function over the values of a dict.
(defn map-over-values [f m]
  (into (empty m) (for [[k v] m] [k (f v)])))

;; Makes a hash map from a list of words with key = word, val = list of indices of that word.
(defn word-indices-map [word-list]
  (pigeonhole (indexed-word-list word-list) second first))

;; Takes two word-lists and returns a list of dicts of [:word <string> :left-index <int> :right-indices (<int>...)] which correspond to all the matching words in those word-lists.
(defn match-graph [left-word-list right-word-list]
  (let [right-word-indices-map (word-indices-map right-word-list)]
    (map (fn [v] {:word          (second v)
                  :left-index    (first v)
                  :right-indices (get right-word-indices-map (second v))})
         (indexed-word-list left-word-list))))

;; Given a node in the graph, returns its first edge.
(defn first-edge [graph-node]
  {:word        (:word graph-node)
   :left-index  (:left-index graph-node)
   :right-index (first (:right-indices graph-node))})

;; Given a node in the graph, returns the a node with the rest of its edges.
(defn rest-edges [graph-node]
  (if (empty? (rest (:right-indices graph-node)))
      {}
      {:word          (:word graph-node)
       :left-index    (:left-index graph-node)
       :right-indices (rest (:right-indices graph-node))}))

;; Returns all edges in a graph-node
(defn graph-node-edges [graph-node]
  (if (empty? (:right-indices graph-node))
      nil
      (cons (first-edge graph-node)
            (graph-node-edges (rest-edges graph-node)))))

;; Takes an edge and a sequence; returns a dict of the sequence with the edge appended if it can "stick"; otherwise returns the sequence. Either way, return sequence is tagged as to whether it matches by use of a dict.
(defn match-with-single-sequence [sequence graph-edge]
  (if (and (= (:left-index graph-edge)
              (+ 1 (:left-index (first sequence))))
           (= (:right-index graph-edge)
              (+ 1 (:right-index (first sequence)))))
      {:match (cons graph-edge sequence)}
      {:non-match sequence}))

;; Takes an edge and a list of sequences; returns a a dict which has a list of sequences (:matches) where the edge can "stick" (with the correspondig edge in each sequence), and a list of sequences where the edge could not stick (:non-matches).
(defn match-with-sequences [sequence-list graph-edge]
  (let [results (map #(match-with-single-sequence % graph-edge) sequence-list)]
    (let [matches     (map :match     (filter :match     results))
          non-matches (map :non-match (filter :non-match results))]
         (if (empty? matches)
             ; new sequences are started when an edge doesn't match any live sequences
             {:new         (list (list graph-edge))
              :non-matches non-matches}
             {:matches     matches
              :non-matches non-matches}))))

;; Given a graph node and a list of possibly live sequences, returns a dict --- :matches - only the sequences which can be continued using an edge from the node, with the new edges attached to them, and :non-matches - the set of sequences which could not be extended from the node.
(defn extend-sequences-from-node [sequence-list graph-node]
  (loop [edges (graph-node-edges graph-node)
         results {:matches     nil
                  :non-matches sequence-list}]
        (if (empty? edges)
            results
            (let [new-results (match-with-sequences (:non-matches results)
                                                    (first edges))]
              ;(println new-results)
              (recur (rest edges)
                     {:matches (concat (:matches results)
                                       (:matches new-results)
                                       (:new     new-results))
                      :non-matches (:non-matches new-results)})))))

;; Converts a sequence of edges into a dict {:left-start <int> :right-start <int> :length <int> :words (<string>...)}
; To increase performance, assumes that sequences are presented in order. Thus, first and last are used rather than min and max. If necessary, further optimization may be obtained by eliminating the call to map and instead directly taking the first and last elements, *then* applying the field extractors.
(defn sequence-to-range [sequence]
  (let [left-indices  (map :left-index  sequence)
        right-indices (map :right-index sequence)
        words         (map :word        sequence)]
       {:left-start  (first left-indices)
        :right-start (first right-indices)
        :length (+ 1 (- (last left-indices)
                        (first left-indices)))
        :words words}))

;; Returns a list of longest-common-subsequences in the two strings, which may possibly contain overlapping sequences.
(defn find-common-subsequences [left-string right-string]
  (map reverse
    (loop [graph (apply match-graph
                        (map (comp split-to-words #(.toLowerCase %))
                             [left-string right-string]))
           live     nil
           complete nil]
          (if (empty? graph)
              (concat live complete)
              (let [new-sequences (extend-sequences-from-node live (first graph))]
                (recur (rest graph)
                       (:matches new-sequences)
                       (concat complete
                               (:non-matches new-sequences))))))))

;; Takes two sequences (A, B) and returns true iff A's nodes are a subset of B's nodes.
(defn both-sides-range-subset? [A-range B-range]
  (and (>= (:left-start A-range)
           (:left-start B-range))
       (>= (:right-start A-range)
           (:right-start B-range))
       (<= (+ (:left-start A-range) (:length A-range))
           (+ (:left-start B-range) (:length B-range)))))

;; Filters a list of ranges to find only the ranges which map to the largest possible set of words.
(defn remove-redundant-ranges [ranges-list]
  (clojure.set/difference
    (set ranges-list)
    (set (map first
              (filter #(and (both-sides-range-subset? (first %) (second %))
                            (not (= (first %) (second %))))
                      (for [a ranges-list b ranges-list]
                           (vector a b)))))))

;; Takes a list of dicts and gives each one a unique numeric ID.
(defn attach-IDs [dict-list]
  (let [id-list (range (count dict-list))]
       (loop [list-no-ids   dict-list
              ids           id-list
              list-with-ids nil]
             (if (empty? list-no-ids)
                 list-with-ids
                 (recur (rest list-no-ids)
                        (rest ids)
                        (cons (conj (first list-no-ids) {:block-id (first ids)})
                              list-with-ids))))))

; TODO: Filter out matches we don't want (such as common words, punctu\ation...)
(defn remove-probably-spurious [ranges-list]
  (identity ranges-list))

;; Returns a list of ranges which have been properly filtered and conflict-resolved so that they can be formatted as HTML without issue.
(defn filtered-match-ranges [left-string right-string]
  ((comp attach-IDs
         remove-probably-spurious
         remove-redundant-ranges
         (partial map sequence-to-range)
         find-common-subsequences)
  left-string right-string))

;; Generates a pair of sorted lists of words, such that each word is tagged with an ID corresponding to the match-block to which it belongs.
(defn tagged-word-lists [left-string right-string]

  (defn id-labeling-fold-func [side words-dict block-range]
         (let [indices (range (side block-range)
                              (+ (side block-range) (:length block-range)))]
           (conj words-dict
                 (into {}
                   (map vector
                        indices
                        (map (fn [d] (conj d {:block-ids (cons (:block-id block-range) (:block-ids d))}))
                             ((apply juxt (map (fn [i] (fn [m] (get m i)))
                                               indices))
                              (map-over-values (fn [w] {:block-ids (:block-ids w)})
                                               words-dict))))))))

  (let [ranges-with-IDs  (filtered-match-ranges left-string right-string)
        left-words-dict  (into {} (indexed-word-list (split-to-words left-string)))
        right-words-dict (into {} (indexed-word-list (split-to-words right-string)))]

       (map (fn [side words-dict]
              (vals
                (merge-with (fn [w id] {:word (:word w) :block-ids (:block-ids id)})
                            (map-over-values (fn [s] {:word s}) words-dict)
                            (reduce (partial id-labeling-fold-func side)
                                    words-dict
                                    ranges-with-IDs))))
            [:left-start     :right-start]
            [left-words-dict right-words-dict])))

;; Transforms a fully processed tagged word list into an HTML string.
(defn generate-HTML [element move-class nil-class tagged-words]

  ;; Takes a single fully processed tagged word and transforms it into HTML.
  (defn tagged-word-to-HTML [word]
    (str "<" element " class=\""
      (apply str (cons (if (empty? (:block-ids word))
                           nil-class
                           move-class)
                       (map #(str " pd-block-" %)
                            (:block-ids word))))
      "\">"
      (:word word)
      "</" element ">"))

  ;; Applies to the whole list of words, makes a string.
  (apply str (map tagged-word-to-HTML
                  tagged-words)))

;; Main function takes a vector of two strings and returns a vector of two (HTML) strings.
(defn ^:export process-strings [left-string right-string]
  (map (partial generate-HTML "span" "pd-move")
       ["pd-delete" "pd-insert"]
       (tagged-word-lists left-string right-string)))

;; TESTING...
(defn ^:export greet [n]
  (str "Hello " n))
